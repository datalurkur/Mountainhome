--- !ruby/object:RDoc::RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: Returns the string resulting from applying <em>format_string</em> to any additional arguments. Within the format string, any characters other than format sequences are copied to the result.
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: The syntax of a format sequence is follows.
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: "  %[flags][width][.precision]type\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character. The field type controls how the corresponding <tt>sprintf</tt> argument is to be interpreted, while the flags modify that interpretation.
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "The field type characters are:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: "    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "The flags modifies the behavior of the formats. The flag characters are:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: "  Flag     | Applies to    | Meaning\n  ---------<tt>---------------</tt>-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | eEfgG         | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------<tt>---------------</tt>-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------<tt>---------------</tt>-----------------------------------------\n   #       | bBoxX         | Use an alternative format.\n           | eEfgG         | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------<tt>---------------</tt>-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | eEfgG         | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------<tt>---------------</tt>-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------<tt>---------------</tt>-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | eEfgG         | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------<tt>---------------</tt>-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "Examples of flags:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: " # `+' and space flag specifies the sign of non-negative numbers.\n sprintf(&quot;%d&quot;, 123)  #=&gt; &quot;123&quot;\n sprintf(&quot;%+d&quot;, 123) #=&gt; &quot;+123&quot;\n sprintf(&quot;% d&quot;, 123) #=&gt; &quot; 123&quot;\n\n # `#' flag for `o' increases number of digits to show `0'.\n # `+' and space flag changes format of negative numbers.\n sprintf(&quot;%o&quot;, 123)   #=&gt; &quot;173&quot;\n sprintf(&quot;%#o&quot;, 123)  #=&gt; &quot;0173&quot;\n sprintf(&quot;%+o&quot;, -123) #=&gt; &quot;-173&quot;\n sprintf(&quot;%o&quot;, -123)  #=&gt; &quot;..7605&quot;\n sprintf(&quot;%#o&quot;, -123) #=&gt; &quot;..7605&quot;\n\n # `#' flag for `x' add a prefix `0x' for non-zero numbers.\n # `+' and space flag disables complements for negative numbers.\n sprintf(&quot;%x&quot;, 123)   #=&gt; &quot;7b&quot;\n sprintf(&quot;%#x&quot;, 123)  #=&gt; &quot;0x7b&quot;\n sprintf(&quot;%+x&quot;, -123) #=&gt; &quot;-7b&quot;\n sprintf(&quot;%x&quot;, -123)  #=&gt; &quot;..f85&quot;\n sprintf(&quot;%#x&quot;, -123) #=&gt; &quot;0x..f85&quot;\n sprintf(&quot;%#x&quot;, 0)    #=&gt; &quot;0&quot;\n\n # `#' for `X' uses the prefix `0X'.\n sprintf(&quot;%X&quot;, 123)  #=&gt; &quot;7B&quot;\n sprintf(&quot;%#X&quot;, 123) #=&gt; &quot;0X7B&quot;\n\n # `#' flag for `b' add a prefix `0b' for non-zero numbers.\n # `+' and space flag disables complements for negative numbers.\n sprintf(&quot;%b&quot;, 123)   #=&gt; &quot;1111011&quot;\n sprintf(&quot;%#b&quot;, 123)  #=&gt; &quot;0b1111011&quot;\n sprintf(&quot;%+b&quot;, -123) #=&gt; &quot;-1111011&quot;\n sprintf(&quot;%b&quot;, -123)  #=&gt; &quot;..10000101&quot;\n sprintf(&quot;%#b&quot;, -123) #=&gt; &quot;0b..10000101&quot;\n sprintf(&quot;%#b&quot;, 0)    #=&gt; &quot;0&quot;\n\n # `#' for `B' uses the prefix `0B'.\n sprintf(&quot;%B&quot;, 123)  #=&gt; &quot;1111011&quot;\n sprintf(&quot;%#B&quot;, 123) #=&gt; &quot;0B1111011&quot;\n\n # `#' for `e' forces to show the decimal point.\n sprintf(&quot;%.0e&quot;, 1)  #=&gt; &quot;1e+00&quot;\n sprintf(&quot;%#.0e&quot;, 1) #=&gt; &quot;1.e+00&quot;\n\n # `#' for `f' forces to show the decimal point.\n sprintf(&quot;%.0f&quot;, 1234)  #=&gt; &quot;1234&quot;\n sprintf(&quot;%#.0f&quot;, 1234) #=&gt; &quot;1234.&quot;\n\n # `#' for `g' forces to show the decimal point.\n # It also disables stripping lowest zeros.\n sprintf(&quot;%g&quot;, 123.4)   #=&gt; &quot;123.4&quot;\n sprintf(&quot;%#g&quot;, 123.4)  #=&gt; &quot;123.400&quot;\n sprintf(&quot;%g&quot;, 123456)  #=&gt; &quot;123456&quot;\n sprintf(&quot;%#g&quot;, 123456) #=&gt; &quot;123456.&quot;\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: The field width is an optional integer, followed optionally by a period and a precision. The width specifies the minimum number of characters that will be written to the result for this field.
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "Examples of width:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: " # padding is done by spaces,       width=20\n # 0 or radix-1.             &lt;------------------&gt;\n sprintf(&quot;%20d&quot;, 123)   #=&gt; &quot;                 123&quot;\n sprintf(&quot;%+20d&quot;, 123)  #=&gt; &quot;                +123&quot;\n sprintf(&quot;%020d&quot;, 123)  #=&gt; &quot;00000000000000000123&quot;\n sprintf(&quot;%+020d&quot;, 123) #=&gt; &quot;+0000000000000000123&quot;\n sprintf(&quot;% 020d&quot;, 123) #=&gt; &quot; 0000000000000000123&quot;\n sprintf(&quot;%-20d&quot;, 123)  #=&gt; &quot;123                 &quot;\n sprintf(&quot;%-+20d&quot;, 123) #=&gt; &quot;+123                &quot;\n sprintf(&quot;%- 20d&quot;, 123) #=&gt; &quot; 123                &quot;\n sprintf(&quot;%020x&quot;, -123) #=&gt; &quot;..ffffffffffffffff85&quot;\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: For numeric fields, the precision controls the number of decimal places displayed. For string fields, the precision determines the maximum number of characters to be copied from the string. (Thus, the format sequence <tt>%10.10s</tt> will always contribute exactly ten characters to the result.)
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "Examples of precisions:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: " # precision for `d', 'o', 'x' and 'b' is\n # minimum number of digits               &lt;------&gt;\n sprintf(&quot;%20.8d&quot;, 123)  #=&gt; &quot;            00000123&quot;\n sprintf(&quot;%20.8o&quot;, 123)  #=&gt; &quot;            00000173&quot;\n sprintf(&quot;%20.8x&quot;, 123)  #=&gt; &quot;            0000007b&quot;\n sprintf(&quot;%20.8b&quot;, 123)  #=&gt; &quot;            01111011&quot;\n sprintf(&quot;%20.8d&quot;, -123) #=&gt; &quot;           -00000123&quot;\n sprintf(&quot;%20.8o&quot;, -123) #=&gt; &quot;            ..777605&quot;\n sprintf(&quot;%20.8x&quot;, -123) #=&gt; &quot;            ..ffff85&quot;\n sprintf(&quot;%20.8b&quot;, -11)  #=&gt; &quot;            ..110101&quot;\n\n # &quot;0x&quot; and &quot;0b&quot; for `#x' and `#b' is not counted for\n # precision but &quot;0&quot; for `#o' is counted.  &lt;------&gt;\n sprintf(&quot;%#20.8d&quot;, 123)  #=&gt; &quot;            00000123&quot;\n sprintf(&quot;%#20.8o&quot;, 123)  #=&gt; &quot;            00000173&quot;\n sprintf(&quot;%#20.8x&quot;, 123)  #=&gt; &quot;          0x0000007b&quot;\n sprintf(&quot;%#20.8b&quot;, 123)  #=&gt; &quot;          0b01111011&quot;\n sprintf(&quot;%#20.8d&quot;, -123) #=&gt; &quot;           -00000123&quot;\n sprintf(&quot;%#20.8o&quot;, -123) #=&gt; &quot;            ..777605&quot;\n sprintf(&quot;%#20.8x&quot;, -123) #=&gt; &quot;          0x..ffff85&quot;\n sprintf(&quot;%#20.8b&quot;, -11)  #=&gt; &quot;          0b..110101&quot;\n\n # precision for `e' is number of\n # digits after the decimal point           &lt;------&gt;\n sprintf(&quot;%20.8e&quot;, 1234.56789) #=&gt; &quot;      1.23456789e+03&quot;\n\n # precision for `f' is number of\n # digits after the decimal point               &lt;------&gt;\n sprintf(&quot;%20.8f&quot;, 1234.56789) #=&gt; &quot;       1234.56789000&quot;\n\n # precision for `g' is number of\n # significant digits                          &lt;-------&gt;\n sprintf(&quot;%20.8g&quot;, 1234.56789) #=&gt; &quot;           1234.5679&quot;\n\n #                                         &lt;-------&gt;\n sprintf(&quot;%20.8g&quot;, 123456789)  #=&gt; &quot;       1.2345679e+08&quot;\n\n # precision for `s' is\n # maximum number of characters                    &lt;------&gt;\n sprintf(&quot;%20.8s&quot;, &quot;string test&quot;) #=&gt; &quot;            string t&quot;\n"
- !ruby/struct:RDoc::Markup::Flow::P 
  :body: "Examples:"
- !ruby/struct:RDoc::Markup::Flow::VERB 
  :body: "   sprintf(&quot;%d %04x&quot;, 123, 123)               #=&gt; &quot;123 007b&quot;\n   sprintf(&quot;%08b '%4s'&quot;, 123, 123)            #=&gt; &quot;01111011 ' 123'&quot;\n   sprintf(&quot;%1$*2$s %2$d %1$s&quot;, &quot;hello&quot;, 8)   #=&gt; &quot;   hello 8 hello&quot;\n   sprintf(&quot;%1$*2$s %2$d&quot;, &quot;hello&quot;, -8)       #=&gt; &quot;hello    -8&quot;\n   sprintf(&quot;%+g:% g:%-g&quot;, 1.23, 1.23, 1.23)   #=&gt; &quot;+1.23: 1.23:1.23&quot;\n   sprintf(&quot;%u&quot;, -123)                        #=&gt; &quot;-123&quot;\n"
full_name: Kernel#format
is_singleton: false
name: format
params: |
  format(format_string [, arguments...] )   => string
  sprintf(format_string [, arguments...] )  => string

visibility: public
