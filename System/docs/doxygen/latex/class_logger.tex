\section{Logger Class Reference}
\label{class_logger}\index{Logger@{Logger}}
A logging class (what more need be said?).  


{\tt \#include $<$CLogger.h$>$}

Inheritance diagram for Logger::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{class_logger}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{CompactItemize}
\item 
enum {\bf LogType} \{ \par
{\bf TraceMessage}, 
{\bf DebugMessage}, 
{\bf InfoMessage}, 
{\bf WarningMessage}, 
\par
{\bf ErrorMessage}, 
{\bf NoOutput}
 \}
\end{CompactItemize}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
void {\bf setPretext} (const string \&text)
\item 
void {\bf setIndentLevel} (int level)
\item 
void {\bf setIndentSize} (int size)
\item 
void {\bf setAbortOnError} (bool abort)
\item 
void {\bf setLogTarget} (const string \&filename)
\item 
void {\bf setLogLevel} ({\bf LogType} level)
\item 
void {\bf clearLogFile} ()
\item 
void {\bf usePrintfFormatting} (bool useOld)
\item 
void {\bf trace} (const string \&format,...)
\item 
void {\bf debug} (const string \&format,...)
\item 
void {\bf info} (const string \&format,...)
\item 
void {\bf warning} (const string \&format,...)
\item 
void {\bf error} (const string \&format,...)
\end{CompactItemize}
\subsection*{Protected Member Functions}
\begin{CompactItemize}
\item 
void \textbf{print} (int logLevel, const string \&format,...)\label{class_logger_b51438e01c6d882593d5eccf88ccf08b}

\end{CompactItemize}
\subsection*{Friends}
\begin{CompactItemize}
\item 
class {\bf Singleton}\label{class_logger_c14a8b7cbcbd5a98fc75ac3df176d864}

\end{CompactItemize}


\subsection{Detailed Description}
A logging class (what more need be said?). 

This is a class used to aid in the output of information. It acts as sort of a merge between c output and c++ output. It's mostly based off of the old printf style, like with ostreams, you don't need to specify data type. It also supports a small set of string replacement tags for easy inserting of time, class names, line numbers, etc... Other features include built in indentation, leveled output (trace, debug, etc...), and outputing to a file or the console. The debug level may be set at compile time allowing certain messages to be completely removed from the code resulting in absolutely zero performance loss (the downside to this is the necessity of macros).

Like the old printf output, this logger will make use of format strings and \% deliniated wild cards. The difference is that instead of just marking variable insertion, tags will also mark special replacements. Here is a list of supported values:

f - \doxyref{File}{p.}{class_file} t - Time c - Class l - Line

Variables will be supported using numerics to index into the passed variables. Here is an example out how to output with this library, as well as equivilent code using the conventional C and C++ methods:

int a = 1, b = 5; Debug(\char`\"{}[\%t] \%2 $\ast$ \%1 = \%2\char`\"{}, a, b); Debug(\char`\"{}[\%t]\char`\"{} $<$$<$ b $<$$<$ \char`\"{}$\ast$\char`\"{} $<$$<$ a $<$$<$ \char`\"{}=\char`\"{} $<$$<$ b); printf(\char`\"{}[\%s]\%i $\ast$ \%i = \%i$\backslash$n\char`\"{}, getTimeString(), b, a, b); cout $<$$<$ \char`\"{}[\char`\"{} $<$$<$ getTimeString() $<$$<$ \char`\"{}] \char`\"{} $<$$<$ b $<$$<$ \char`\"{} $\ast$ \char`\"{} $<$$<$ a $<$$<$ \char`\"{} = \char`\"{} $<$$<$ b $<$$<$ endl;

All three will output the following (assuming it is 6:30PM): [18:30] 5 $\ast$ 1 = 5

\begin{Desc}
\item[Author:]Brent Wilson \end{Desc}
\begin{Desc}
\item[Date:]8/14/07 \end{Desc}
\begin{Desc}
\item[{\bf Todo}]Enforce a line width? \end{Desc}
\begin{Desc}
\item[{\bf Todo}]Add array lookups (so you can just pass an array, rather than each element)? \end{Desc}
\begin{Desc}
\item[{\bf Todo}]Add separators? (ie ---------Init---------) \end{Desc}


\subsection{Member Enumeration Documentation}
\index{Logger@{Logger}!LogType@{LogType}}
\index{LogType@{LogType}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Logger::LogType}}\label{class_logger_8f625bd9ec5f706cb67b725a98743c04}


LogType enumerates the different log levels available to the system. \begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{TraceMessage@{TraceMessage}!Logger@{Logger}}\index{Logger@{Logger}!TraceMessage@{TraceMessage}}\item[{\em 
TraceMessage\label{class_logger_8f625bd9ec5f706cb67b725a98743c046087907fa3e6d3c24d08191d56927a7c}
}]Used for tracing the codepath. \index{DebugMessage@{DebugMessage}!Logger@{Logger}}\index{Logger@{Logger}!DebugMessage@{DebugMessage}}\item[{\em 
DebugMessage\label{class_logger_8f625bd9ec5f706cb67b725a98743c04c16a6da2454d984812b6e0e055e0101d}
}]Used to help find errors in the code. \index{InfoMessage@{InfoMessage}!Logger@{Logger}}\index{Logger@{Logger}!InfoMessage@{InfoMessage}}\item[{\em 
InfoMessage\label{class_logger_8f625bd9ec5f706cb67b725a98743c04f65c1d1090f981c78f2b690152cd3e6b}
}]Used for generic information that would be helpful. \index{WarningMessage@{WarningMessage}!Logger@{Logger}}\index{Logger@{Logger}!WarningMessage@{WarningMessage}}\item[{\em 
WarningMessage\label{class_logger_8f625bd9ec5f706cb67b725a98743c04a4f3d512dd9e88656ec58c48314c863e}
}]Used when questionable behavior arises. \index{ErrorMessage@{ErrorMessage}!Logger@{Logger}}\index{Logger@{Logger}!ErrorMessage@{ErrorMessage}}\item[{\em 
ErrorMessage\label{class_logger_8f625bd9ec5f706cb67b725a98743c04518e14de27c1c5cf0055dcb50d02a703}
}]Used to log errors that could have major repercussions. \index{NoOutput@{NoOutput}!Logger@{Logger}}\index{Logger@{Logger}!NoOutput@{NoOutput}}\item[{\em 
NoOutput\label{class_logger_8f625bd9ec5f706cb67b725a98743c04cbc54575c20d17bf2e863f171382023e}
}]Used simply to shut off all output. \end{description}
\end{Desc}



\subsection{Member Function Documentation}
\index{Logger@{Logger}!setPretext@{setPretext}}
\index{setPretext@{setPretext}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setPretext (const string \& {\em text})}\label{class_logger_1d90365f5f62d0b34b538479f392efb5}


Sets the pretext string that is printed as the object is being created. Often this will make use of the various built in replacements like t and c. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em text}]The text to print out during object construction. \end{description}
\end{Desc}
\index{Logger@{Logger}!setIndentLevel@{setIndentLevel}}
\index{setIndentLevel@{setIndentLevel}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setIndentLevel (int {\em level})}\label{class_logger_78b2fe280464b2a4dce903453e619b4e}


Sets an indent level for output. By setting the indent level, leading whitespace is added to all output to aid in clarity. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em level}]The number of indentations to place before output. \end{description}
\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{setIndentSize}{p.}{class_logger_a0aa2f433fab2d25c0012b34e26d8345} \end{Desc}
\index{Logger@{Logger}!setIndentSize@{setIndentSize}}
\index{setIndentSize@{setIndentSize}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setIndentSize (int {\em size})}\label{class_logger_a0aa2f433fab2d25c0012b34e26d8345}


Sets the number of spaces per indentation. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em size}]The number of spaces in a single indentation. \end{description}
\end{Desc}
\index{Logger@{Logger}!setAbortOnError@{setAbortOnError}}
\index{setAbortOnError@{setAbortOnError}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setAbortOnError (bool {\em abort})}\label{class_logger_fb6d7634bfe23f391e518e43bfdae305}


Sets the a parameter that determines if LogType 'Error' messages will cause the program to abort once the message has been printed out. This may make debugging certain errors easier. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em abort}]The new value to determine if errors result in an abort. \end{description}
\end{Desc}
\index{Logger@{Logger}!setLogTarget@{setLogTarget}}
\index{setLogTarget@{setLogTarget}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setLogTarget (const string \& {\em filename})}\label{class_logger_68104a27d9d0905cf92ab317ffde4d78}


This function is used to determine where program output is directed. Output can be sent to a log file or standard out. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em filename}]Sets the file to log to. If this value is NULL, logging will go to standard out. \end{description}
\end{Desc}
\index{Logger@{Logger}!setLogLevel@{setLogLevel}}
\index{setLogLevel@{setLogLevel}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::setLogLevel ({\bf LogType} {\em level})}\label{class_logger_ef77c2ecc2ccccfd1672b182945c4b6d}


The log level may be set at both compile and run time. When set at compile time, certain log messages are not even compiled into the code, thus the compile level acts as a hard cap for the ammount of output whereas this acts as a soft cap. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em level}]The minimum level of output to actually log. \end{description}
\end{Desc}
\index{Logger@{Logger}!clearLogFile@{clearLogFile}}
\index{clearLogFile@{clearLogFile}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::clearLogFile ()}\label{class_logger_8f83a8bb6fcc43c90138daa280600cf6}


This will delete the old log file. \index{Logger@{Logger}!usePrintfFormatting@{usePrintfFormatting}}
\index{usePrintfFormatting@{usePrintfFormatting}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::usePrintfFormatting (bool {\em useOld})}\label{class_logger_7bd81cdd7c5f0632d93e6565a4c5c2b8}


Sets a flag the decides if the old printf wildcard notation should be used. This means all of the special tags (time, file, etc...) will be unusable, as will the special variable notation (1, 2, etc...). All log functions will act just like printf (want more info? man printf). \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em useOld}]Determines if printf notation should be used. \end{description}
\end{Desc}
\index{Logger@{Logger}!trace@{trace}}
\index{trace@{trace}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::trace (const string \& {\em format},  {\em ...})}\label{class_logger_e896f38e0d19fa64498f015e3e7f17f3}


Outputs a message with a log level of TraceMessage \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em format}]The output format to use. \item[{\em ...}]The arguments used by the format \end{description}
\end{Desc}
\index{Logger@{Logger}!debug@{debug}}
\index{debug@{debug}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::debug (const string \& {\em format},  {\em ...})}\label{class_logger_8200626ed44639d6659471810c7d93f8}


Outputs a message with a log level of DebugMessage \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em format}]The output format to use. \item[{\em ...}]The arguments used by the format \end{description}
\end{Desc}
\index{Logger@{Logger}!info@{info}}
\index{info@{info}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::info (const string \& {\em format},  {\em ...})}\label{class_logger_f649a13a057bca832e4385646bcb088d}


Outputs a message with a log level of InfoMessage \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em format}]The output format to use. \item[{\em ...}]The arguments used by the format \end{description}
\end{Desc}
\index{Logger@{Logger}!warning@{warning}}
\index{warning@{warning}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::warning (const string \& {\em format},  {\em ...})}\label{class_logger_ee6f603115452060a09fe2703cdf6db4}


Outputs a message with a log level of WarningMessage \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em format}]The output format to use. \item[{\em ...}]The arguments used by the format \end{description}
\end{Desc}
\index{Logger@{Logger}!error@{error}}
\index{error@{error}!Logger@{Logger}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Logger::error (const string \& {\em format},  {\em ...})}\label{class_logger_cead4a87ec2c3ede9ecfdfae678e179f}


Outputs a message with a log level of ErrorMessage \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em format}]The output format to use. \item[{\em ...}]The arguments used by the format \end{description}
\end{Desc}


The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
CLogger.h\end{CompactItemize}
